<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.ss1742.com</id>
    <title>1742·小博文</title>
    <updated>2019-07-29T15:12:23.971Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.ss1742.com"/>
    <link rel="self" href="https://blog.ss1742.com/atom.xml"/>
    <subtitle>这是我的真博客</subtitle>
    <logo>https://blog.ss1742.com/images/avatar.png</logo>
    <icon>https://blog.ss1742.com/favicon.ico</icon>
    <rights>All rights reserved 2019, 1742·小博文</rights>
    <entry>
        <title type="html"><![CDATA[买卖股票的最佳时机 II]]></title>
        <id>https://blog.ss1742.com/post/mai-mai-gu-piao-de-zui-jia-shi-ji-ii</id>
        <link href="https://blog.ss1742.com/post/mai-mai-gu-piao-de-zui-jia-shi-ji-ii">
        </link>
        <updated>2019-07-29T15:05:28.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</code></pre>
<p>示例 2:</p>
<pre><code>输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</code></pre>
<p>示例 3:</p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<pre><code class="language-js">function maxProfit(prices) {
	let buy = Number.MAX_SAFE_INTEGER;
	let profit = 0;
	for (let i = 0, len = prices.length; i &lt; len; i++) {
		if (prices[i] &lt; buy) {
			buy = prices[i];
		} else {
			profit += prices[i] - buy;
			buy = prices[i];
		}
	}
	return profit;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[买卖股票的最佳时机]]></title>
        <id>https://blog.ss1742.com/post/mai-mai-gu-piao-de-zui-jia-shi-ji</id>
        <link href="https://blog.ss1742.com/post/mai-mai-gu-piao-de-zui-jia-shi-ji">
        </link>
        <updated>2019-07-29T15:00:21.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p>示例 2:</p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<pre><code class="language-js">function maxProfit(prices) {
	let min = Number.MAX_SAFE_INTEGET;
	let profit = 0;
	for (let i = 0, len = prices.length; i &lt; len; i++) {
		if (prices[i] &lt; min) {
			min = prices[i];
		} else if (prices[i] - min &gt; profit) {
			profit = prices[i] - min;
		}
	}
	return profit;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反转链表]]></title>
        <id>https://blog.ss1742.com/post/fan-zhuan-lian-biao</id>
        <link href="https://blog.ss1742.com/post/fan-zhuan-lian-biao">
        </link>
        <updated>2019-07-29T14:51:26.000Z</updated>
        <content type="html"><![CDATA[<p>反转一个单链表。</p>
<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<pre><code class="language-js">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
// 常规
function reverseList1(head) {
	if (head === null || head.next === null) return head;
	let p = head.next;
	head.next = null;
	let temp = null;
	while (p !== null) {
		temp = p.next;
		p.next = head;
		head = p;
		p = temp;
	}
	return head;
}
// 递归
function reverseList2(head) {
	if (head === null || head.next === null) return head;
	let new_head = reverseList2(head.next);
	head.next.next = head;
	head.next = null;
	return new_head;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[合并区间]]></title>
        <id>https://blog.ss1742.com/post/he-bing-qu-jian</id>
        <link href="https://blog.ss1742.com/post/he-bing-qu-jian">
        </link>
        <updated>2019-07-29T14:46:54.000Z</updated>
        <content type="html"><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<pre><code>输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
</code></pre>
<p>示例 2:</p>
<pre><code>输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
</code></pre>
<pre><code class="language-js">function merge(intervals) {
	if (intervals.length &lt; 2) return intervals;
	intervals = intervals.sort((a, b) =&gt; a[0] - b[0]);
	return intervals.reduce((a, b) =&gt; {
		let temp = a[a.length - 1];
		if (temp[1] &lt; b[0]) {
			return [...a, b];
		} else {
			temp[1] = Math.max(temp[1], b[1]);
		}
		return a;
	}, [intervals[0]]);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组中的第K个最大元素]]></title>
        <id>https://blog.ss1742.com/post/shu-zu-zhong-de-di-k-ge-zui-da-yuan-su</id>
        <link href="https://blog.ss1742.com/post/shu-zu-zhong-de-di-k-ge-zui-da-yuan-su">
        </link>
        <updated>2019-07-29T14:41:52.000Z</updated>
        <content type="html"><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。</p>
<p>示例 :</p>
<pre><code>输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
</code></pre>
<pre><code class="language-js">function findKthLargest(nums, k) {
	let temp = qSort(nums);
	return k &lt;= temp.length ? temp[k - 1] : null;
}
function qSort(nums) {
	if (nums.length &lt; 2) return nums;
	let left = [], right = [], temp = nums[0];
	for (let i = 0, len = nums.length; i &lt; len; i++) {
		if (nums[i] &lt; temp) {
			right.push(nums[i]);
		} else {
			left.push(nums[i]);
		}
	}
	return [...qSort(left), temp, ...qSort(right)];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简化路径]]></title>
        <id>https://blog.ss1742.com/post/jian-hua-lu-jing</id>
        <link href="https://blog.ss1742.com/post/jian-hua-lu-jing">
        </link>
        <updated>2019-07-29T14:36:37.000Z</updated>
        <content type="html"><![CDATA[<p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<p>示例</p>
<pre><code>输入：&quot;/a/./b/../../c/&quot;
输出：&quot;/c&quot;
解释：注意，最后一个目录名后面没有斜杠。
</code></pre>
<pre><code class="language-js">function simplifyPath(path) {
	let res = [];
	let paths = path.split('/');
	for (let i = 0, len = paths.length; i &lt; len; i++) {
		if (paths[i] === '..') {
			res.pop();
		} else if (paths[i] &amp;&amp; paths[i] !== '.') {
			res.push(paths[i]);
		}
	}
	return res.length &gt; 0 ? ('/' + res.join('/')) : '/';
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[愈发觉得看书真的很重要]]></title>
        <id>https://blog.ss1742.com/post/kan-shu</id>
        <link href="https://blog.ss1742.com/post/kan-shu">
        </link>
        <updated>2019-07-28T16:02:13.000Z</updated>
        <content type="html"><![CDATA[<p>看书，不只是限制于技术类，同时需要对社会学、经济学的书籍多看一点。</p>
<p>不追求马上获得什么，一点点来。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[翻转字符串里的单词]]></title>
        <id>https://blog.ss1742.com/post/fan-zhuan-zi-fu-chuan-li-de-dan-ci</id>
        <link href="https://blog.ss1742.com/post/fan-zhuan-zi-fu-chuan-li-de-dan-ci">
        </link>
        <updated>2019-07-26T16:40:11.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<pre><code class="language-js">function reverseWords(s) {
			return s.trim().replace(/(\s)+/g, '$1').split(' ').reverse().join(' ');
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最长公共前缀]]></title>
        <id>https://blog.ss1742.com/post/zui-chang-gong-gong-qian-zhui</id>
        <link href="https://blog.ss1742.com/post/zui-chang-gong-gong-qian-zhui">
        </link>
        <updated>2019-07-26T14:38:56.000Z</updated>
        <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀</p>
<pre><code class="language-js">function longestCommonPrefix(s) {
			if (s.length === 0) return '';
			let common = s[0];
			for (let i = 0, len = s.length; i &lt; len; i++) {
				while (s[i].indexOf(common) !== 0) {
					common = common.substring(0, common.length - 1);
					if (!common) return '';
				}
			}
			return common;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无重复字符的最长子串]]></title>
        <id>https://blog.ss1742.com/post/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan</id>
        <link href="https://blog.ss1742.com/post/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan">
        </link>
        <updated>2019-07-26T13:29:05.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度</p>
<pre><code class="language-js">function lengthOfLongestSubstring(s) {
			if (s.length &lt; 2) return s.length;
			let res = [];
			let temp = s[0];
			for (let i = 1, len = s.length; i &lt; len; i++) {
				if (temp.includes(s[i])) {
					res.push(temp);
					temp = `${temp.substring(temp.indexOf(s[i]) + 1)}${s[i]}`;
				} else {
					temp = `${temp}${s[i]}`;
				}
			}
			res.push(temp);
			return res.reduce((a, b) =&gt; Math.max(a, b.length), 0);
}
</code></pre>
]]></content>
    </entry>
</feed>