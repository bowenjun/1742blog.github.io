<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.ss1742.com</id>
    <title>1742·小博文</title>
    <updated>2019-08-02T17:19:16.688Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.ss1742.com"/>
    <link rel="self" href="https://blog.ss1742.com/atom.xml"/>
    <subtitle>这是我的真博客</subtitle>
    <logo>https://blog.ss1742.com/images/avatar.png</logo>
    <icon>https://blog.ss1742.com/favicon.ico</icon>
    <rights>All rights reserved 2019, 1742·小博文</rights>
    <entry>
        <title type="html"><![CDATA[快排]]></title>
        <id>https://blog.ss1742.com/post/kuai-pai</id>
        <link href="https://blog.ss1742.com/post/kuai-pai">
        </link>
        <updated>2019-08-02T16:13:51.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">// 递归
function quickSort1(arr) {
	if (arr.length &lt; 2) return arr;
	let num = arr[0], left = [], right = [];
	for (let i = 1, len = arr.length; i &lt; len; i++) {
		if (num &lt; arr[i]) {
			right.push(arr[i]);
		} else {
			left.push(arr[i]);
		}
	}
	return [...quickSort1(left), num, ...quickSort1(right)];
}

// 非递归
function quickSort2(num, left, right) {
    var list = [[left, right]]; // 将[left,right]存入数组中，类似于递归入栈
    while (list.length &gt; 0) { // 若list不为空，循环弹出list最后一个数组进行快排
        var now = list.pop(); // 弹出list末尾。(也可用list.shift()取出list第一个数组，但在数据量较大时，这种方式效率较低)
        if (now[0] &gt;= now[1]) { // 若左右指针相遇，待排序数组长度小宇1，则无需进行快排(注意不能写成now[0]==now[1]，这里now[0]是有可能大于now[1]的
            continue;
        }
        var i = now[0], j = now[1], flag = now[0]; // 以下与递归方法相同，请参考上面的递归详解
        while (i &lt; j) {
            while (num[j] &gt;= num[flag] &amp;&amp; j &gt; flag) j--;
            if (i &gt;= j) {
                break;
            }
            while (num[i] &lt;= num[flag] &amp;&amp; i &lt; j) i++;
            let temp = num[flag];
            num[flag] = num[j];
            num[j] = num[i];
            num[i] = temp;
            flag = i;
        }
        list.push([now[0], flag - 1]); // 将flag左边数组作为待排序数组，只需将左右指针放入list即可。
        list.push([flag + 1, now[1]]); // 将flag右边数组作为待排序数组，只需将左右指针放入list即可。
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大数相加]]></title>
        <id>https://blog.ss1742.com/post/da-shu-xiang-jia</id>
        <link href="https://blog.ss1742.com/post/da-shu-xiang-jia">
        </link>
        <updated>2019-08-01T02:51:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">function add(a, b) {
		let la = a.length;
		let lb = b.length;
		if (la &gt; lb) {
			b = b.padStart(la, '0');
		} else {
			a = a.padStart(lb, '0');
		}
		let tempA = a.split('').reverse();
		let tempB = b.split('').reverse();
		let res = [];
		for (let i = 0, len = tempA.length; i &lt; len; i++) {
			res.push(parseInt(tempA[i]) + parseInt(tempB[i]));
		}
		for (let i = 0, len = res.length; i &lt; len; i++) {
			if (res[i] &gt;= 10) {
				res[i] = parseInt(res[i]) - 10;
				res[i+1] = parseInt(res[i+1]) + 1;
			}
		}

		return res.reverse().join('');
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安全]]></title>
        <id>https://blog.ss1742.com/post/an-quan</id>
        <link href="https://blog.ss1742.com/post/an-quan">
        </link>
        <updated>2019-08-01T02:09:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="sql-注入">sql 注入</h3>
<p>表单提交的数据里带有 sql 命令</p>
<h3 id="xss">xss</h3>
<p>Cross-site scripting 脚本攻击</p>
<p>防御</p>
<pre><code class="language-js">// &lt; &gt; 转义
str = str.replace(/&lt;/g,'&amp;lt;');
str = str.replace(/&lt;/g,'&amp;gt;');
// 引号 转义
str = str.replace(/&quot;/g,'&amp;quto;');
str = str.replace(/'/g,'&amp;#39;');
str = str.replace(/ /g,'&amp;#32;');
</code></pre>
<h3 id="csrf">CSRF</h3>
<p>Cross-site request forgery 跨站请求伪造</p>
<p>防御</p>
<ul>
<li>
<p>验证码</p>
</li>
<li>
<p>伪随机值</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[统计页面使用到的所有标签]]></title>
        <id>https://blog.ss1742.com/post/tong-ji-ye-mian-shi-yong-dao-de-suo-you-biao-qian</id>
        <link href="https://blog.ss1742.com/post/tong-ji-ye-mian-shi-yong-dao-de-suo-you-biao-qian">
        </link>
        <updated>2019-08-01T02:05:46.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">function findAll() {
	const all = document.querySelectorAll('*');
	return all.reduce((a, b) =&gt; {
		let key = b.nodeName.toLowerCase();
		if (!a[key]) {
			a[key] = 0;
		}
		a[key]++;
		return a;
	}, {});
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[读书有感——level-0.0.1]]></title>
        <id>https://blog.ss1742.com/post/du-shu-you-gan-level-001</id>
        <link href="https://blog.ss1742.com/post/du-shu-you-gan-level-001">
        </link>
        <updated>2019-07-31T16:11:58.000Z</updated>
        <content type="html"><![CDATA[<p>利用晚上11点以后的时间，正在看《曾国藩的正面与侧面》—— 张宏杰，开始坚持记账(来自曾国藩老师)</p>
<p>利用地铁，2天已读《邓小平传》—— 理查德伊文思 前七章</p>
<p>实践来了，什么书都读。其实是才开始阅读，并不是说马上就变成了和两位伟人一样有同样的思想报复和才干，写出来的句子也就只有这可怜巴巴的两句。但是我觉得坚持完8月，可能有意想不到的收获。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[复原IP地址]]></title>
        <id>https://blog.ss1742.com/post/fu-yuan-ip-di-zhi</id>
        <link href="https://blog.ss1742.com/post/fu-yuan-ip-di-zhi">
        </link>
        <updated>2019-07-31T16:00:24.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>示例:</p>
<pre><code>输入: &quot;25525511135&quot;
输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]
</code></pre>
<pre><code class="language-js">var restoreIpAddresses = function(s) {
    let fun = getObj();
    fun.findOut(s, []);
    return fun.res;
};

var getObj = function() {
    let res = [];
    function findOut(str, arr) {
        if (!str.length &amp;&amp; arr.length === 4) return res.push(arr.join('.'));
        if (arr.length === 4) return;
        let temp = '', tempArr = str.split('');
        for (let i = 0; i &lt; 3; i++) {
            temp = tempArr.pop() + temp;
            if (isValid(temp)) {
                let a = [...arr];
                a.unshift(temp);
                findOut(tempArr.join(''), a);
            }
        }
    }
    return {
        findOut,
        res
    }
}

var isValid = function(s) {
    return Number(s) &lt; 256 &amp;&amp; Number(s).toString() === s;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[axios上传进度]]></title>
        <id>https://blog.ss1742.com/post/axios-shang-chuan-jin-du</id>
        <link href="https://blog.ss1742.com/post/axios-shang-chuan-jin-du">
        </link>
        <updated>2019-07-30T16:11:28.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">const config = {
    onUploadProgress: progressEvent =&gt; console.log(progressEvent.loaded / progressEvent.total)
}
axios.put('/upload/server', data, config);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端性能优化]]></title>
        <id>https://blog.ss1742.com/post/qian-duan-xing-neng-you-hua</id>
        <link href="https://blog.ss1742.com/post/qian-duan-xing-neng-you-hua">
        </link>
        <updated>2019-07-30T09:36:36.000Z</updated>
        <content type="html"><![CDATA[<p>前端性能优化：减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用更好性能的api和构建优化。</p>
<p>参考链接: <a href="https://www.cnblogs.com/xiaohuochai/p/9178390.html#anchor1">前端性能优化的七大手段</a></p>
<h3 id="减少请求数量">减少请求数量</h3>
<h4 id="合并">合并</h4>
<p>如果不合并影响</p>
<ul>
<li>文件之间插入的上行请求，增加了 n - 1 个网络延迟</li>
<li>受丢包问题影响更严重</li>
<li>经过代理服务器时可能会被断开</li>
</ul>
<p>合并带来的问题</p>
<ul>
<li>首屏渲染</li>
<li>缓存失效</li>
</ul>
<p>建议</p>
<ul>
<li>公共库合并</li>
<li>不同页面单独合并</li>
</ul>
<h4 id="图片处理">图片处理</h4>
<ol>
<li>雪碧图<br>
减少了请求数量，但如果图片过大一次加载过慢。现在因字体图片和 svg 图片流行渐渐使用少了<br>
2. base64<br>
base64 格式嵌入到 html 中，减少了请求数量，但是编码用8位字符表示信息中的6个位，编码后大小比原始值扩大了 33%<br>
3. 使用字体图标来替代图片</li>
</ol>
<h4 id="减少重定向">减少重定向</h4>
<p>如果使用重定向，要使用 301 永久重定向</p>
<h4 id="使用缓存">使用缓存</h4>
<p>Cache-Control 和 Expires</p>
<h4 id="不使用-import">不使用 @import</h4>
<h4 id="避免使用空-src-和-href">避免使用空 src 和 href</h4>
<h3 id="减小资源大小">减小资源大小</h3>
<h4 id="压缩">压缩</h4>
<ul>
<li>html 压缩</li>
<li>css 压缩</li>
<li>js 压缩与混淆</li>
<li>图片压缩（tinypng）</li>
</ul>
<h4 id="gzip">gzip</h4>
<h3 id="优化网络连接">优化网络连接</h3>
<h4 id="cdncontent-delivery-network">cdn(Content Delivery Network)</h4>
<h4 id="dns-预解析">dns 预解析</h4>
<pre><code class="language-html">&lt;link rel=&quot;dns-prefecth&quot; href=&quot;https://xxx.com&quot; /&gt;
</code></pre>
<h4 id="并行连接">并行连接</h4>
<p>域名发散，使用多个域名增加并发数</p>
<h4 id="持久连接">持久连接</h4>
<p>keep-alive</p>
<h4 id="管道化连接">管道化连接</h4>
<p>http2协议，单条连接多路复用</p>
<h3 id="优化资源下载">优化资源下载</h3>
<h4 id="资源加载位置">资源加载位置</h4>
<p>css 头部，js 尾部，布局 js 放在 head 中</p>
<h4 id="资源加载时机">资源加载时机</h4>
<ol>
<li>异步 script 标签<br>
defer: html 加载完后执行<br>
async: 下载完成立即执行<br>
2. 模块按需加载<br>
webpack 1. import() 2.require.ensure<br>
3. 懒加载</li>
</ol>
<h3 id="减少重绘回流">减少重绘回流</h3>
<h4 id="样式">样式</h4>
<ol>
<li>避免使用层级较深的选择器</li>
<li>避免使用 css 表达式</li>
<li>避免使用 table 布局</li>
<li>能用 css 尽量不要用 js</li>
</ol>
<h4 id="渲染层">渲染层</h4>
<ol>
<li>将需要多次重绘的元素独立，如设置 absolute，可以减少重绘范围</li>
<li>动画使用硬件渲染</li>
</ol>
<h4 id="dom-优化">dom 优化</h4>
<ol>
<li>缓存 dom</li>
<li>减少 dom 深度和数量</li>
<li>批量操作 dom</li>
<li>
<ul>
<li>事件代理</li>
</ul>
</li>
<li>
<ul>
<li>防抖节流</li>
</ul>
</li>
<li>及时清理环境</li>
</ol>
<h3 id="使用更好的api">使用更好的api</h3>
<h4 id="用对-css-选择器">用对 css 选择器</h4>
<h4 id="使用-requestanimationframe-替代计时器">使用 requestAnimationFrame 替代计时器</h4>
<h4 id="使用-intersectionobserver-实现图片可视区域懒加载">使用 IntersectionObserver 实现图片可视区域懒加载</h4>
<h4 id="使用-webworker">使用 webworker</h4>
<h3 id="构建优化">构建优化</h3>
<p>webpack</p>
<h4 id="打包公共代码">打包公共代码</h4>
<h4 id="动态导入-按需加载">动态导入 按需加载</h4>
<h4 id="剔除无用代码">剔除无用代码</h4>
<p>tree shaking</p>
<p>js - uglifyjs</p>
<p>css - purify css</p>
<h4 id="长缓存优化">长缓存优化</h4>
<ol>
<li>
<p>hash 替换为 chunkhash</p>
</li>
<li>
<p>使用 name 而不是 id</p>
</li>
</ol>
<h4 id="公用代码内联">公用代码内联</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[买卖股票的最佳时机 II]]></title>
        <id>https://blog.ss1742.com/post/mai-mai-gu-piao-de-zui-jia-shi-ji-ii</id>
        <link href="https://blog.ss1742.com/post/mai-mai-gu-piao-de-zui-jia-shi-ji-ii">
        </link>
        <updated>2019-07-29T15:05:28.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</code></pre>
<p>示例 2:</p>
<pre><code>输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</code></pre>
<p>示例 3:</p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<pre><code class="language-js">function maxProfit(prices) {
	let buy = Number.MAX_SAFE_INTEGER;
	let profit = 0;
	for (let i = 0, len = prices.length; i &lt; len; i++) {
		if (prices[i] &lt; buy) {
			buy = prices[i];
		} else {
			profit += prices[i] - buy;
			buy = prices[i];
		}
	}
	return profit;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[买卖股票的最佳时机]]></title>
        <id>https://blog.ss1742.com/post/mai-mai-gu-piao-de-zui-jia-shi-ji</id>
        <link href="https://blog.ss1742.com/post/mai-mai-gu-piao-de-zui-jia-shi-ji">
        </link>
        <updated>2019-07-29T15:00:21.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</code></pre>
<p>示例 2:</p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<pre><code class="language-js">function maxProfit(prices) {
	let min = Number.MAX_SAFE_INTEGET;
	let profit = 0;
	for (let i = 0, len = prices.length; i &lt; len; i++) {
		if (prices[i] &lt; min) {
			min = prices[i];
		} else if (prices[i] - min &gt; profit) {
			profit = prices[i] - min;
		}
	}
	return profit;
}
</code></pre>
]]></content>
    </entry>
</feed>