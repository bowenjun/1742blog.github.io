<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.ss1742.com</id>
    <title>1742·小博文</title>
    <updated>2019-08-09T16:35:20.818Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.ss1742.com"/>
    <link rel="self" href="https://blog.ss1742.com/atom.xml"/>
    <subtitle>这是我的真博客</subtitle>
    <logo>https://blog.ss1742.com/images/avatar.png</logo>
    <icon>https://blog.ss1742.com/favicon.ico</icon>
    <rights>All rights reserved 2019, 1742·小博文</rights>
    <entry>
        <title type="html"><![CDATA[按奇偶排序数组]]></title>
        <id>https://blog.ss1742.com/post/an-qi-ou-pai-xu-shu-zu</id>
        <link href="https://blog.ss1742.com/post/an-qi-ou-pai-xu-shu-zu">
        </link>
        <updated>2019-08-09T16:33:20.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。</p>
<p>你可以返回满足此条件的任何数组作为答案。</p>
<p>示例：</p>
<pre><code>输入：[3,1,2,4]
输出：[2,4,3,1]
输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
</code></pre>
<pre><code class="language-js">var sortArrayByParity = function(A) {
    for (let i = 0, j = A.length; i &lt; j;) {
        if (A[i] % 2 === 0) {
            i++;
        } else if (A[--j] % 2 === 0) {
            A[i] ^= A[j];
            A[j] ^= A[i];
            A[i++] ^= A[j];
        }
    }
    return A;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hermes Engine 初探]]></title>
        <id>https://blog.ss1742.com/post/hermes-engine-chu-tan</id>
        <link href="https://blog.ss1742.com/post/hermes-engine-chu-tan">
        </link>
        <updated>2019-08-08T15:29:38.000Z</updated>
        <content type="html"><![CDATA[<p>Hermes引擎是Facebook研发，在React-Native Android端用于替换JavaScript Core的JavaScript引擎。Hermes引擎的优势是适合移动端的轻量级JavaScript引擎，使用aot编译，可以减少Android端内存使用，减小安装包大小，提升执行效率。</p>
<h3 id="hermes的特色">Hermes的特色</h3>
<ul>
<li>预编译字节码（引擎加载二进制代码效率高于运行JS脚本）</li>
<li>无JIT编译器（减小了引擎大小，优化内存占用，但直接运行JS脚本的性能差于V8和JSC）</li>
<li>针对移动端的垃圾回收策略</li>
</ul>
<h3 id="主流javascript引擎">主流JavaScript引擎</h3>
<p>V8（Google）、JavaScriptCore（Apple）、SpiderMonkey（Firefox）</p>
<h3 id="rn中的javascript引擎">RN中的JavaScript引擎</h3>
<h4 id="weex">Weex</h4>
<p>Android：V8，iOS：JavaScriptCore</p>
<h4 id="rn">RN</h4>
<p>Android：JavaScriptCore（Hermes、V8），iOS：JavaScriptCore（Apple要求）</p>
<p>注：Hermes Engine在React-native 0.60.2 版本后支持</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[animation]]></title>
        <id>https://blog.ss1742.com/post/animation</id>
        <link href="https://blog.ss1742.com/post/animation">
        </link>
        <updated>2019-08-07T16:04:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="animation-play-state">animation-play-state</h3>
<p><code>paused</code> 暂停</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[bind/apply/call]]></title>
        <id>https://blog.ss1742.com/post/bindapplycall</id>
        <link href="https://blog.ss1742.com/post/bindapplycall">
        </link>
        <updated>2019-08-06T17:51:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="bind">bind</h3>
<pre><code class="language-js">Function.prototype.bind2 = function(context) {
    let _this = this;
    let argsParent = Array.prototype.slice.call(arguments, 1);
    return function() {
        var args = argsParent.concat(Array.prototype.slice.call(arguments)); // 转化成数组
        _this.apply(context, args);
    };
}
</code></pre>
<h3 id="apply">apply</h3>
<pre><code class="language-js">Function.prototype.apply2 = function(context, arr) {
    let context = context || window; // 因为传进来的context有可能是null
    context.fn = this;
    let args = [];
    let params = arr || [];
    for (var i = 0; i &lt; params.length; i++) {
        args.push(&quot;params[&quot; + i + &quot;]&quot;); // 不这么做的话 字符串的引号会被自动去掉 变成了变量 导致报错
    }
    args = args.join(&quot;,&quot;);

    let result = eval(&quot;context.fn(&quot; + args + &quot;)&quot;); // 相当于执行了context.fn(arguments[1], arguments[2]);

    delete context.fn;
    return result; // 因为有可能this函数会有返回值return
}
</code></pre>
<h3 id="call">call</h3>
<pre><code class="language-js">Function.prototype.call2 = function(context) {
    let context = context || window; // 因为传进来的context有可能是null
    context.fn = this;
    let args = [];
    for (var i = 1; i &lt; arguments.length; i++) {
        args.push(&quot;arguments[&quot; + i + &quot;]&quot;); // 不这么做的话 字符串的引号会被自动去掉 变成了变量 导致报错
    }
    args = args.join(&quot;,&quot;);

    let result = eval(&quot;context.fn(&quot; + args + &quot;)&quot;); // 相当于执行了context.fn(arguments[1], arguments[2]);

    delete context.fn;
    return result; // 因为有可能this函数会有返回值return
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[状态码 499]]></title>
        <id>https://blog.ss1742.com/post/zhuang-tai-ma-499</id>
        <link href="https://blog.ss1742.com/post/zhuang-tai-ma-499">
        </link>
        <updated>2019-08-05T15:38:54.000Z</updated>
        <content type="html"><![CDATA[<p><code>499</code> 对应的是 <code>client has closed connection</code>，客户端请求等待链接已经关闭，这很有可能是因为服务器端处理的时间过长，客户端等得“不耐烦”了。还有一种原因是两次提交 <code>post</code> 过快就会出现 <code>499</code>。</p>
<p>解决方法：</p>
<ul>
<li>前端将 <code>timeout</code> 最大等待时间设置大一些</li>
<li><code>nginx</code> 上配置 <code>proxy_ignore_client_abort on</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[整数中1出现的次数]]></title>
        <id>https://blog.ss1742.com/post/zheng-shu-zhong-1-chu-xian-de-ci-shu</id>
        <link href="https://blog.ss1742.com/post/zheng-shu-zhong-1-chu-xian-de-ci-shu">
        </link>
        <updated>2019-08-04T14:58:08.000Z</updated>
        <content type="html"><![CDATA[<p>求出1 ~ 13的整数中1出现的次数,并算出100 ~ 1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<p>题解<br>
当计算右数第 i 位包含的 X 的个数时：</p>
<ul>
<li>取第 i 位左边（高位）的数字，乘以 10i−1，得到基础值 a。</li>
<li>取第 i 位数字，计算修正值：<br>
- 如果大于 X，则结果为 a+10i−1。<br>
- 如果小于 X，则结果为 a。<br>
- 如果等 X，则取第 i 位右边（低位）数字，设为 b，最后结果为 a+b+1。</li>
</ul>
<pre><code class="language-js">function NumberOf1Between1AndN_Solution2(n) {
    let count = 0;
    for (let i = 1; i &lt;= n; i *= 10) {
        let a = n / i, b = n % i;
        //之所以补8，是因为当百位为0，则a/10==(a+8)/10，
        //当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)
        count += (a + 8) / 10 * i + ((a % 10 == 1) ? b + 1 : 0);
    }
    return count;
}
</code></pre>
<p>暴力思路</p>
<pre><code class="language-js">function NumberOf1Between1AndN_Solution(n) {
    return [
			...Array
			.from({ length: n })
			.keys()
		]
		.map(item =&gt; item + 1)
    .join('')
    .replace(/[^1]/g, '')
    .length;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快排]]></title>
        <id>https://blog.ss1742.com/post/kuai-pai</id>
        <link href="https://blog.ss1742.com/post/kuai-pai">
        </link>
        <updated>2019-08-02T16:13:51.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">// 递归
function quickSort1(arr) {
	if (arr.length &lt; 2) return arr;
	let num = arr[0], left = [], right = [];
	for (let i = 1, len = arr.length; i &lt; len; i++) {
		if (num &lt; arr[i]) {
			right.push(arr[i]);
		} else {
			left.push(arr[i]);
		}
	}
	return [...quickSort1(left), num, ...quickSort1(right)];
}

// 非递归
function quickSort2(num, left, right) {
    var list = [[left, right]]; // 将[left,right]存入数组中，类似于递归入栈
    while (list.length &gt; 0) { // 若list不为空，循环弹出list最后一个数组进行快排
        var now = list.pop(); // 弹出list末尾。(也可用list.shift()取出list第一个数组，但在数据量较大时，这种方式效率较低)
        if (now[0] &gt;= now[1]) { // 若左右指针相遇，待排序数组长度小宇1，则无需进行快排(注意不能写成now[0]==now[1]，这里now[0]是有可能大于now[1]的
            continue;
        }
        var i = now[0], j = now[1], flag = now[0]; // 以下与递归方法相同，请参考上面的递归详解
        while (i &lt; j) {
            while (num[j] &gt;= num[flag] &amp;&amp; j &gt; flag) j--;
            if (i &gt;= j) {
                break;
            }
            while (num[i] &lt;= num[flag] &amp;&amp; i &lt; j) i++;
            let temp = num[flag];
            num[flag] = num[j];
            num[j] = num[i];
            num[i] = temp;
            flag = i;
        }
        list.push([now[0], flag - 1]); // 将flag左边数组作为待排序数组，只需将左右指针放入list即可。
        list.push([flag + 1, now[1]]); // 将flag右边数组作为待排序数组，只需将左右指针放入list即可。
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大数相加]]></title>
        <id>https://blog.ss1742.com/post/da-shu-xiang-jia</id>
        <link href="https://blog.ss1742.com/post/da-shu-xiang-jia">
        </link>
        <updated>2019-08-01T02:51:53.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">function add(a, b) {
		let la = a.length;
		let lb = b.length;
		if (la &gt; lb) {
			b = b.padStart(la, '0');
		} else {
			a = a.padStart(lb, '0');
		}
		let tempA = a.split('').reverse();
		let tempB = b.split('').reverse();
		let res = [];
		for (let i = 0, len = tempA.length; i &lt; len; i++) {
			res.push(parseInt(tempA[i]) + parseInt(tempB[i]));
		}
		for (let i = 0, len = res.length; i &lt; len; i++) {
			if (res[i] &gt;= 10) {
				res[i] = parseInt(res[i]) - 10;
				res[i+1] = parseInt(res[i+1]) + 1;
			}
		}

		return res.reverse().join('');
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安全]]></title>
        <id>https://blog.ss1742.com/post/an-quan</id>
        <link href="https://blog.ss1742.com/post/an-quan">
        </link>
        <updated>2019-08-01T02:09:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="sql-注入">sql 注入</h3>
<p>表单提交的数据里带有 sql 命令</p>
<h3 id="xss">xss</h3>
<p>Cross-site scripting 脚本攻击</p>
<p>防御</p>
<pre><code class="language-js">// &lt; &gt; 转义
str = str.replace(/&lt;/g,'&amp;lt;');
str = str.replace(/&lt;/g,'&amp;gt;');
// 引号 转义
str = str.replace(/&quot;/g,'&amp;quto;');
str = str.replace(/'/g,'&amp;#39;');
str = str.replace(/ /g,'&amp;#32;');
</code></pre>
<h3 id="csrf">CSRF</h3>
<p>Cross-site request forgery 跨站请求伪造</p>
<p>防御</p>
<ul>
<li>
<p>验证码</p>
</li>
<li>
<p>伪随机值</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[统计页面使用到的所有标签]]></title>
        <id>https://blog.ss1742.com/post/tong-ji-ye-mian-shi-yong-dao-de-suo-you-biao-qian</id>
        <link href="https://blog.ss1742.com/post/tong-ji-ye-mian-shi-yong-dao-de-suo-you-biao-qian">
        </link>
        <updated>2019-08-01T02:05:46.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">function findAll() {
	const all = document.querySelectorAll('*');
	return all.reduce((a, b) =&gt; {
		let key = b.nodeName.toLowerCase();
		if (!a[key]) {
			a[key] = 0;
		}
		a[key]++;
		return a;
	}, {});
}
</code></pre>
]]></content>
    </entry>
</feed>